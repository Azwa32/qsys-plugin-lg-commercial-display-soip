-- Basic Framework Plugin
-- by QSC
-- October 2020

-- Information block for the plugin
PluginInfo = {
  Name = "LG~LG Commercial Display Serial over IP",
  Version = "1.0",
  BuildVersion = "0.0.0.1",
  Id = "<guid>",
  Author = "Aaron Mitchell",
  Description = "Plugin for basic control of LG Commercial displays via serial over IP devices such as USR IOT lan to serial adapter or through a serial port accessable over lan eg. Visionary Solutions",
  ShowDebug = true
}

-- Define the color of the plugin object in the design
local Colors = {
  White = {255, 255, 255},
  Black = {0,0,0},
  Background = {193, 193, 193},
  Button = {105, 105, 105},
}
function GetColor(props)
  return Colors
end

-- The name that will initially display when dragged into a design
function GetPrettyName(props)
  return "LG Commercial Display SoIP " .. PluginInfo.Version
end

-- Define User configurable Properties of the plugin
function GetProperties()
  local props = {}
  table.insert(props, {
    Name = "Debug Print",
    Type = "enum",
    Choices = {"None", "Tx/Rx", "Tx", "Rx", "Function Calls", "All"},
    Value = "None"
  })
  
  table.insert(props, {
  			Name = "IP Address",
  			Type = "string",
  			Value = "192.168.1.50"
  })
  
  table.insert(props, {
  			Name = "Port",
  			Type = "integer",
  			Min = 1,
  			Max = 100000,
  			Value = 23
  })
  
  table.insert(props, {
  			Name = "ID",
  			Type = "integer",
  			Min = 1,
  			Max = 1000,
  			Value = 1
  })
  return props
end

-- Optional function to update available properties when properties are altered by the user
function RectifyProperties(props)
  if props.plugin_show_debug.Value == false then 
    props["Debug Print"].IsHidden = true 
  end
  return props
end

-- Defines the Controls used within the plugin
function GetControls(props)
  local ctrls = {}
  table.insert(ctrls, {
    Name = "Status",
    ControlType = "Indicator",
    IndicatorType = "Status",
    UserPin = true,
    PinStyle = "Output",
  })
  
  table.insert(ctrls, {
    Name = "PowerOn",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "PowerOff",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Power",
    ControlType = "Indicator",
    IndicatorType = "Led",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Mute",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Menu",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Up",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Down",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Left",
    ControlType = "Button",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Right",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Enter",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Back",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    UserPin = true
  })
  
  table.insert(ctrls, {
    Name = "Input",
    ControlType = "Button",
    ButtonType = "Trigger",
    PinStyle = "Both",
    Count = 4,
    UserPin = true
  })
  return ctrls
end

--Layout of controls and graphics for the plugin UI to display
function GetControlLayout(props)
  local layout = {}
  local graphics = {}
    table.insert(graphics,{
        Type = "GroupBox",
        Fill = Colors.Background,
        StrokeWidth = 1,
        StrokeColor = Colors.White,
        Position = {0,0},
        Size = {166,337}
      })
    
      layout["PowerOn"] = {
        Legend = "On",
        TextSize = 9,
        Style = "Button",
        Position = {18,33},
        Size = {36,16},
        Color = Colors.Button
      }
    
      layout["PowerOff"] = {
        Legend = "Off",
        TextSize = 9,
        Style = "Button",
        Position = {110,33},
        Size = {36,16},
        Color = Colors.Button
      }
    
      layout["Power"] = {
        Style = "LED",
        Position = {77,33},
        Size = {16,16},
        Color = {255,0,0}
      }
    
      layout["Mute"] = {
        Legend = "Mute",
        TextSize = 9,
        Style = "Button",
        Position = {18,61},
        Size = {36,16},
        Color = Colors.Button
      }
    
      layout["Menu"] = {
        Legend = "Menu",
        TextSize = 9,
        Style = "Button",
        Position = {110,82},
        Size = {36,16},
        Color = Colors.Button
      }
    
      layout["Enter"] = {
        Legend = "Enter",
        TextSize = 9,
        Style = "Button",
        Position = {65,108},
        Size = {36,26},
        Color = Colors.Button
      }
    
      layout["Up"] = {
        Style = "Button",
        Position = {65,82},
        Size = {36,26},
        Color = Colors.Button
      }
    
      layout["Down"] = {
        Style = "Button",
        Position = {65,135},
        Size = {36,26},
        Color = Colors.Button
      }
    
      layout["Left"] = {
        Style = "Button",
        Position = {29,108},
        Size = {36,26},
        Color = Colors.Button
      }
    
      layout["Right"] = {
        Style = "Button",
        Position = {101,108},
        Size = {36,26},
        Color = Colors.Button
      }
    
      layout["Back"] = {
        Legend = "Back",
        TextSize = 9,
        Style = "Button",
        Position = {18,161},
        Size = {36,26},
        Color = Colors.Button
      }
    
    table.insert(graphics,{
        Type = "Label",
        Text = "HDMI Input",
        TextSize = 9,
        HTextAlign = "Left",
        Fill = Colors.Background,
        Color = Colors.Black,
        Position = {18,199},
        Size = {128,16}
      })
    
    inputStartPos = {18,215}
    inputSize = {32,16}
    
    InputIndex = 1
    layout["Input "..tostring(InputIndex)] = {
      Legend = tostring(InputIndex),
      TextSize = 9,
      TextColor = Colors.White,
      Style = "Button",
      Size = inputSize,
      Position = {inputStartPos[1]+(inputSize[1]*(InputIndex-1)), inputStartPos[2]},
      Margin = 1,
      Color = Colors.Button,
    }
    
    InputIndex = 2
    layout["Input "..tostring(InputIndex)] = {
      Legend = tostring(InputIndex),
      TextSize = 9,
      TextColor = Colors.White,
      Style = "Button",
      Size = inputSize,
      Position = {inputStartPos[1]+(inputSize[1]*(InputIndex-1)), inputStartPos[2]},
      Margin = 1,
      Color = Colors.Button,
    }
    
    InputIndex = 3
    layout["Input "..tostring(InputIndex)] = {
      Legend = tostring(InputIndex),
      TextSize = 9,
      TextColor = Colors.White,
      Style = "Button",
      Size = inputSize,
      Position = {inputStartPos[1]+(inputSize[1]*(InputIndex-1)), inputStartPos[2]},
      Margin = 1,
      Color = Colors.Button,
    }
    
    InputIndex = 4
    layout["Input "..tostring(InputIndex)] = {
      Legend = tostring(InputIndex),
      TextSize = 9,
      TextColor = Colors.White,
      Style = "Button",
      Size = inputSize,
      Position = {inputStartPos[1]+(inputSize[1]*(InputIndex-1)), inputStartPos[2]},
      Margin = 1,
      Color = Colors.Button,
    }
    
    layout["Status"] = {
      Style = "Text",
      TextSize = 9,
      UserPin = true,
      PinStyle = "Output",
      Size = {128,16},
      Position = {18,289}
    }
  return layout, graphics
end

--Start event based logic
if Controls then
  -- For LG-75UV340C
  
  PowerOn = Controls.PowerOn
  PowerOff = Controls.PowerOff
  PowerState = Controls.PowerState
  Mute = Controls.Mute
  Up = Controls.Up
  Down = Controls.Down
  Left = Controls.Left
  Right = Controls.Right
  Enter = Controls.Enter
  Return = Controls.Back
  Menu = Controls.Menu
  ID = Properties.ID.Value
  port = Properties.Port.Value
  status = Controls.Status 
  
  --Commands
  commands = {
    power = 'ka ',
    mute = 'ke ',
    ir = 'mc ',
    on = ' 01',
    off = ' 00',
    input = 'xb ',
    inputs = {
      ' 90',
      ' 91',
      ' 92',
      ' 93'
    },
    remote_lock = 'km ',
    dl = '\r',
  }
  new_message = ""
  
  sendBuffer = {}                             -- table for outgoing commands      
  sendDelay = .2                              -- delay for outgoing commands
  sendDelayTimer = Timer.New()                
  
  --variables
  
  -------------------------------------------------------------------------------------
  -- TCP Class --
  -------------------------------------------------------------------------------------
  local TCP = {}
  TCP.__index = TCP
  
  -- Constructor
  function TCP:new(deviceIp, devicePort)
  local base = {
      address = deviceIp or "",
      port = devicePort or 23,
      keepaliveCmd = nil,
      tcp = TcpSocket.New(),
      connected = false,
      reconnecting = false,
      heartbeat = Timer.New(),
      heartbeatTime = 5,
      verboseDebug = false,
      status = {
          states = {
              ok = 0,
              compromised = 1,
              fault = 2,
              notPresent = 3,
              missing = 4,
              initialising = 5,
          }
      },
  }
  
  -- Initialise base objects
  base.tcp.ReadTimeout = 0
  base.tcp.WriteTimeout = 0
  base.tcp.ReconnectTimeout = 5
  base.status.state = base.status.states.notPresent
  
  if Controls.status then
      Controls.status.Value = base.status.states.notPresent
  end   
  
  if base.verboseDebug then 
      print("TCP Connection created:")
      print("Address: " .. tostring(base.address))
      print("Port: " .. tostring(base.port))
      print("TCP object exists: " .. tostring(base.tcp ~= nil))
  end
  
  -- set metatable and return the base settings
  setmetatable(base, TCP) -- describes table behavior
      base:setupEventHandlers()
      return base
  end
  
  -- Methods
  function TCP:setKeepalive(cmd)
      self.keepaliveCmd = cmd
  end
  
  function TCP:setHeartbeatTime(seconds)
      self.heartbeatTime = seconds
  end
  
  function TCP:setStatus(mode)
      self.status.state = mode
      if self.statusEvent then
          self.statusEvent(mode, self)
      end
  end
  
  function TCP:sendCommand(cmd)
      if cmd then
          local success, err = pcall(function() -- error handling for issues writing to the socket
              if self.verboseDebug then 
                  print("TCP command sent: "..cmd)
              end
              self.tcp:Write(cmd)
          end)
          if not success then
              print("sendCommand error: "..tostring(err)) 
          end
      end
  end
  
  function TCP:Connect()
      print("TCP connecting to "..self.address..":"..self.port)
      self.tcp:Connect(self.address, self.port)
  end
  
  function TCP:Disconnect()
      print("TCP disconnecting...")
      self.tcp:Disconnect()
  end
  
  function TCP:isConnected()
      return self.tcp.IsConnected
  end
  
  function TCP:setupEventHandlers()
      local tcpInstance = self  -- Store reference to avoid scope issues  
      self.tcp.EventHandler = function(tcp, evt, err) --Event Handler for the TCP socket
          if evt == TcpSocket.Events.Connected then
              print("socket connected")
              tcpInstance.heartbeat:Start(tcpInstance.heartbeatTime)  -- start heartbeat timer
              tcpInstance.connected = true 
              tcpInstance.reconnecting = false
              tcpInstance:setStatus(tcpInstance.status.states.ok)
              return
          elseif evt == TcpSocket.Events.Reconnect then
              if not tcpInstance.reconnecting or tcpInstance.verboseDebug then
                  print("socket reconnecting...")
                  tcpInstance.connected = false
                  tcpInstance.reconnecting = true
                  tcpInstance:setStatus(tcpInstance.status.states.initialising)
              end
          elseif evt == TcpSocket.Events.Data then
              local message = tcp:ReadLine(TcpSocket.EOL.Any)
              if (message ~= nil) and (message ~= '') then
                  if tcpInstance.verboseDebug then 
                      print("TCP Received: " .. message)
                  end
                  if tcpInstance.msgEvent then
                      tcpInstance.msgEvent(message, tcpInstance)
                  end
              end
          elseif evt == TcpSocket.Events.Closed then
              print("socket closed by remote")
              tcpInstance:setStatus(tcpInstance.status.states.compromised)
              tcpInstance.connected = false
          elseif evt == TcpSocket.Events.Error then
              tcpInstance:setStatus(tcpInstance.status.states.fault)
              if tcpInstance.verboseDebug then
                  print("socket error: " .. tostring(err))
              end
              tcpInstance.connected = false
          elseif evt == TcpSocket.Events.Timeout then
              print("socket closed due to timeout")
              tcpInstance:setStatus(tcpInstance.status.states.missing)
              tcpInstance.connected = false
          else
              print("unknown socket event: " .. tostring(evt))
          end
      end
  
      self.heartbeat.EventHandler = function()
          if tcpInstance.connected and tcpInstance.keepaliveCmd then
              tcpInstance:sendCommand(tcpInstance.keepaliveCmd)
              if tcpInstance.verboseDebug then
                  print("heartbeat sent")
              end
          end
      end
  end
  -------------------------------------------------------------------------------------
  -------------------------------------------------------------------------------------
  
  
  
  -- Format strings containing non-printable characters so they are readable.
  function debugFormat(string) 
    local visual = ""
    for i=1,#string do
      local byte = string:sub(i,i)
      if string.byte(byte) >= 32 and string.byte(byte) <= 126 then
        visual = visual..byte
      else
        visual = visual..string.format("[0x%02X]",string.byte(byte))
      end
    end
    return visual
  end
  
  --Controls--
  
  --Eventhandlers
  PowerOn.EventHandler = function()
    queueCommand(commands.power..ID..commands.on)
  end
  
  PowerOff.EventHandler = function()
    queueCommand(commands.power..ID..commands.off)  
  end
  
  Mute.EventHandler = function()
    if Mute.Boolean == true then
      queueCommand(commands.mute..ID..commands.on)  
    else 
      queueCommand(commands.mute..ID..commands.off)
    end
  end
  
  for i = 1, #Controls.Input do
    Controls.Input[i].EventHandler = function(c)
      for j = 1, #Controls.Input do
        Controls.Input[j].Boolean = (j==i) 
      end
    queueCommand(commands.input..ID..commands.inputs[i])
    end
  end
  
  Menu.EventHandler = function()
    queueCommand(commands.ir..ID..' 43')  
  end
  
  Up.EventHandler = function()
    queueCommand(commands.ir..ID..' 40')  
  end
  
  Down.EventHandler = function()
    queueCommand(commands.ir..ID..' 41')  
  end
  
  Left.EventHandler = function()
    queueCommand(commands.ir..ID..' 07')  
  end
  
  Right.EventHandler = function()
    queueCommand(commands.ir..ID..' 06')  
  end
  
  Enter.EventHandler = function()
    queueCommand(commands.ir..ID..' 44')  
  end
  
  Return.EventHandler = function()
    queueCommand(commands.ir..ID..' 28')  
  end
  
  
  --parse commands as they are received
  function parseCommand(command)
    print("Received: ", command)
    rawGain = string.sub(command, 1, 2)  
   -- parsing gains
    if string.find(command, 'DsG') then
      rawGain = tonumber(string.sub(command, 4, 6))
      rawChan = string.sub(command, 7, 8)
      rawValue = string.match(command, "*(.*)")
      value = tonumber(rawValue) / 10
      channel = tonumber(rawChan) + 1
      for command = 1, #cmd do
        if rawGain == cmd[command]['ctrl'] then
          cmd[command]['gainCtrl'][channel].Value = value
        end
      end
    end
  end
  
  
  -- Add command to the outgoing queue.
  function queueCommand(command, now)
    local wait = 0 
    if tcpConnection.isConnected then wait = 1 end
    Timer.CallAfter(function()
      local cmdDl = command..'\r'
      if now then table.insert(sendBuffer, 1, command) else table.insert(sendBuffer, command) end -- Add command to end of sendBuffer. If 'now' is true, add to the beggining of the sendBuffer.
      doSend()
    end, wait)
  end
  
  -- Send command from buffer.
  function doSend() 
    if #sendBuffer > 0 and tcpConnection.isConnected and not sendWait then  -- If there are commands in the buffer, send the next command.
      local command = table.remove(sendBuffer, 1)
      tcpConnection:sendCommand(command..commands.dl)
      print("Sending:", debugFormat(command))
      lastCommand = command
      sendDelaySet()
    end
  end
  
  function sendDelaySet(ctl)  -- Set flag to wait for ACK or Timeout before sending next command. If called with true ( sendDelaySet(true) ), this will immediately dispatch the next command in the buffer.
    if ctl then
      sendDelayTimer:Stop()
      sendWait = false
      doSend()  
    else
      sendWait = true
      sendDelayTimer:Start(sendDelay)
    end  
  end
  sendDelayTimer.EventHandler = sendDelaySet
  
  
  
  -- Startup --
  function Startup()
    tcpConnection = TCP:new(Properties["IP Address"].Value, port)
  
    -- tcp callbacks --
    tcpConnection.statusEvent = function(state) -- needs to be run after initialising TCP:new(Controls.IP.String, port) but before Connect()
      Controls.Status.Value = state
    end
  
    tcpConnection.msgEvent = function(msg)
      parseCommand(new_message)
    end
    --------------------
  
    tcpConnection:Connect()
    tcpConnection:setKeepalive(commands.remote_lock..ID..commands.on)
  end 
  
  Startup()
end

